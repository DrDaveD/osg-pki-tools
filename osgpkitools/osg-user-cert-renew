#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
This script is used to submit multiple certifcate requests and
the intended user for the script is the GridAdmin.
This script requests certificates and then approves as well as issues them
in bulk (limit of 50 at a time).
This script works in two modes:
1) Requesting single host certificate with -H option
2) Request multiple host certificates with hostnames stored in a file -f option
"""

import pdb
import urllib
import httplib
import sys
import ConfigParser
import simplejson
import time
import re
import os
import errno
import getpass
import StringIO
import base64
import M2Crypto
from optparse import OptionParser
from optparse import OptionGroup
import optparse
import sys
import textwrap
import traceback
import subprocess
import ssl
import tempfile

from osgpkitools import OSGPKIUtils
from OSGPKIUtils import CreateOIMConfig
from OSGPKIUtils import extractHostname
from OSGPKIUtils import extractEEC
from OSGPKIUtils import get_request_count
from OSGPKIUtils import check_response_500
from OSGPKIUtils import check_failed_response
from OSGPKIUtils import print_failure_reason_exit
from OSGPKIUtils import check_for_pending
from OSGPKIUtils import charlimit_textwrap
from ExceptionDefinitions import *


# Set up Option Parser
#

def parse_args():
    """This function parses all the arguments, validates them and then stores them
    in a dictionary that is used throughout the script."""

    usage = \
        'usage: %prog [options] arg\nUsage:%prog -h/--help [for detailed explanations of options]'
    parser = OptionParser(usage)
    parser.add_option(
        '-k',
        '--pkey',
        action='store',
        dest='userprivkey',
        help="Specify Requestor's private key (PEM Format).\n If not specified\
             will take the value of X509_USER_KEY or $HOME/.globus/userkey.pem"
            ,
        metavar='PKEY',
        default=None,
        )
    parser.add_option(
        '-c',
        '--cert',
        action='store',
        dest='usercert',
        help="Specify Requestor's certificate (PEM Format).\n If not specified\
             will take the value of X509_USER_CERT or $HOME/.globus/usercert.pem"
            ,
        default=None,
        metavar='CERT',
        )
    parser.add_option(
        '-T',
        '--test',
        action='store_true',
        dest='test',
        help='Run in test mode',
        default=False,
        )
    parser.add_option(
        '-t',
        '--timeout',
        action='store',
        dest='timeout',
        help='Specify the timeout in minutes',
        default=5,
        )
    parser.add_option(
        '-q',
        '--quiet',
        action='store_false',
        dest='verbose',
        default=True,
        help="don't print status messages to stdout",
        )
    (args, values) = parser.parse_args()
    arguments = dict()

    try:
        timeout = int(args.timeout)
        if not timeout >= 0:
            charlimit_textwrap('Your timeout value cannot be a negative integer.\nExiting now'
                               )
            raise ValueError
    except ValueError:
        raise ValueError('Invalid timeout value. Please enter a non-negative integer value.\n'
                         )
    print 'Using timeout of %d minutes' % timeout

    certdir = './'

    if args.userprivkey is None:
        try:
            userprivkey = os.environ['X509_USER_KEY']
        except:
            if os.path.exists(str(os.environ['HOME'])
                              + '/.globus/userkey.pem'):
                userprivkey = str(os.environ['HOME']) \
                    + '/.globus/userkey.pem'
            else:
                raise FileNotFoundException('Key file',
                        'Could not locate the private key file')
    else:
        userprivkey = args.userprivkey

    if os.path.exists(userprivkey):
        pass
    else:
        raise FileNotFoundException(userprivkey,
                                    'Could not locate the private key file'
                                    )
    if args.usercert is None:
        try:
            usercert = os.environ['X509_USER_CERT']
        except:
            usercert = str(os.environ['HOME']) + '/.globus/usercert.pem'
            if os.path.exists(str(os.environ['HOME'])
                              + '/.globus/usercert.pem'):
                usercert = str(os.environ['HOME']) \
                    + '/.globus/usercert.pem'
            else:
                raise FileNotFoundException('Certificate File',
                        'Could not locate the certificate file')
    else:
        usercert = args.usercert

    
    if os.path.exists(usercert):
        pass
    else:
        raise FileNotFoundException(usercert,
                                    'Could not locate the certificate file'
                                    )
    
    if args.test:
        OIM = True
    else:
        OIM = False

    arguments.update({'mode': OIM})
    arguments = CreateOIMConfig(OIM, **arguments)
    #if vars().has_key('args'):
    #    arguments.update({'args': args})
    #if vars().has_key('values'):
    #    arguments.update({'values': values})
    #if vars().has_key('hostname'):
    #    arguments.update({'hostname': hostname})
    #if vars().has_key('domain'):
    #    arguments.update({'domain': domain})
    #if vars().has_key('outkeyfile'):
    #    arguments.update({'outkeyfile': outkeyfile})
    arguments.update({'timeout': timeout})
    arguments.update({'usercert': usercert})
    arguments.update({'userprivkey': userprivkey})
    arguments.update({'certdir': certdir})
    return arguments


#################################################

# We make the request here, causing the generation of the CSR and then
# pass the ID returned from the server along. The ID is the key that OIM
# uses for all certificate operations via the API
#

def connect_renew(**arguments):
    """This function connects to the user renew API and passes the DN
    and the serial number to API to get back the request ID.
    """ 

    print 'Connecting to server to renew certificate...'
    params = urllib.urlencode({'serial_id': arguments['serial_number'],
                               }, doseq=True)
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = M2Crypto.httpslib.HTTPSConnection(arguments['hostsec'],
            ssl_context=arguments['ssl_context'])
    try:
        conn.request('POST', arguments['renewurl'], params, headers)
        print "Conn request succeeded"
        #conn.request('POST', arguments['renewurl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed : %s' % (requrl, e))
        raise e
    data = response.read()
    print "data is ",data
    #This if block is to catch failures and would exit the script
    if not 'OK' in response.reason:
        print_failure_reason_exit(data)
    conn.close()
    check_failed_response(data)
    return_data = simplejson.loads(data)
    request_id = return_data['request_id']
    #for (key, value) in return_data.iteritems():
    #    if 'host_request_id' in key:
    #        reqid = value
    #        print 'Id is:', reqid
    if not reqid:
        raise UnexpectedBehaviourException("Request Id not found in data. Script will not exit")
    arguments.update({'reqid': reqid})
    return arguments


# ID from the request is passed in here via secure connection and the request
# gets approved automatically since it's a bulk request. We also issue the
# certificate (i.e. OIM contacts the CA on our behalf to get the cert) in this
# function
#

#def connect_approve(**arguments):
#    """This function accepts an ssl_context instance which contains information about the established ssl connection
#    and a dictionary consisting of all parameters and their values,
#    It approves the request that is submitted to the OIM by connect_request.
#    """
#
#    print 'Connecting to server to approve certificate...'
#    params = urllib.urlencode({'host_request_id': arguments['reqid']})
#    headers = {'Content-type': arguments['content_type'],
#               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
#    conn = M2Crypto.httpslib.HTTPSConnection(arguments['host'],
#            ssl_context=arguments['ssl_context'])
#    try:
#        conn.request('POST', arguments['appurl'], params, headers)
#        response = conn.getresponse()
#    except httplib.HTTPException, e:
#        charlimit_textwrap('Connection to %s failed: %s'
#                           % (arguments['appurl'], repr(e)))
#        raise e
#    except AttributeError, e:
#        raise e
#    check_response_500(response)
#    if not 'OK' in response.reason:
#        raise NotOKException(response.status, response.reason)
#    data = response.read()
#    conn.close()
#    issurl = arguments['issurl']
#    if 'OK' in data:
#        print 'Contacting Server to initiate certificate issuance.'
#        newrequrl = arguments['issurl']
#        conn = M2Crypto.httpslib.HTTPSConnection(arguments['host'],
#                ssl_context=arguments['ssl_context'])
#        try:
#            conn.request('POST', newrequrl, params, headers)
#            response = conn.getresponse()
#        except httplib.HTTPException, e:
#            charlimit_textwrap('Connection to %s failed: %s'
#                               % (newrequrl, e))
#            raise e
#        data = response.read()
#        conn.close()
#        check_failed_response(data)
#    else:
#        raise NotOKException('Failed', simplejson.loads(data)['detail'])
#    #elif not 'OK' in data:
#    #    raise NotOKException('Failed', simplejson.loads(data)['detail'])

# Here's where things have gotten dicey during the testing phase -
# We retrieve the certificate from OIM after it has retrieved it from the CA
# This is where things tend to fall apart - if the delay is to long and the
# request to the CA times out, the whole script operation fails. I'm not
# terribly pleased with that at the moment, but it is out of my hands since
# a GOC staffer has to reset the request to be able to retrieve the
# certificate
#

def extract_certs(pkcs7raw, arguments):
    """This function accepts the hostname, pkcs7raw dump of the certificate and
    a dictionary that consists variables and their value against them.
    It write the certificates to file system by calling write_certificate function"""
    pkcs7_file = tempfile.NamedTemporaryFile()
    pkcs7_file.write(str(pkcs7raw))
    pkcs7_file.flush()
    temp_file = tempfile.NamedTemporaryFile()
    print ''

    # ### printing our all the certificates received from OIM to a temporrary file###
    subprocess.call([
        'openssl',
        'pkcs7',
        '-print_certs',
        '-in',
        os.path.abspath(pkcs7_file.name),
        '-out',
        os.path.abspath(temp_file.name),
        ])
    pkcs7_file.close()
    certString = temp_file.read()
    temp_file.close()
    # ## Extracting the hostname ###

    hostname = extractHostname(certString)

    # ## Extracting the EEC certificate ###

    eecString = extractEEC(certString, hostname)
    #arguments.update({'hostname': hostname})
    arguments.update({'eecString': eecString})
    write_certificate(**arguments)
    return


def write_certificate(**arguments):
    """ This function writes the extracted EEC certificate"""
    hostname = arguments['hostname']
    eecString = arguments['eecString']
    hostname = hostname.strip(' \n').replace('/', '-')
    pem_filename = hostname + '.pem'
    temp_file = tempfile.NamedTemporaryFile()
    temp_file.write(eecString)
    temp_file.flush()
    if os.path.exists(pem_filename):
        charlimit_textwrap('The file %s already exists.' % pem_filename)
        pem_filename = '%s-%s.%s' % (hostname, arguments['reqid'], 'pem'
                )
    subprocess.call(['cp', os.path.abspath(temp_file.name), pem_filename])  # ## fix for move the file to desired name ###
    os.chmod(pem_filename, 0644)
    cwd = os.getcwd()
    try:
        os.chdir(arguments['certdir'])
    except OSError, e:
        charlimit_textwrap('''The directory %s does not exist or you cannot access the directory
    .Please report the bug to goc@opensciencegrid.org.a
    %s''',
                           arguments['certdir'], e)
        raise OSError
    os.chdir(cwd)
    charlimit_textwrap('''Certificate written to %s%s 
    '''
                       % (arguments['certdir'], pem_filename))
    temp_file.close()
    return


def connect_retrieve(num_requests, **arguments):
    """This fucntion accepts a dictionary consisting of variables and their values against it.
    It retrieves the certificate from the OIM."""

    iterations = 1
    print 'Issuing certificate...'
    params = urllib.urlencode({'host_request_id': arguments['reqid']})
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = httplib.HTTPSConnection(arguments['host'])
    try:
        conn.request('POST', arguments['returl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed: %s' % (newurl, e))
        raise httplib.HTTPException
    check_response_500(response)
    data = response.read()
    if not 'PENDING' in response.reason:
        if not 'OK' in response.reason:
            print_failure_reason_exit(data)
    conn.close()
    charlimit_textwrap('Waiting for response from Certificate Authority. Please wait.'
                       )
    iterations = 0
    while 'PENDING' in data:
        conn.request('POST', arguments['returl'], params, headers)
        try:
            response = conn.getresponse()
        except httplib.HTTPException, e:
            charlimit_textwrap('Connection to %s failed: %s' % (newurl,
                               e))
            raise httplib.HTTPException
        check_response_500(response)
        data = response.read()
        conn.close()
        iterations = check_for_pending(data, iterations, **arguments)
    pkcs7raw = simplejson.dumps(simplejson.loads(data), sort_keys=True,
                                indent=2)
    check_failed_response(data)

    # The slice and dice on the JSON output to get the certificate out
    # happens here - the problem is that the new lines are getting all screwy
    # in the output from OIM. We stringify the data, replace all the text
    # newline characters with actual new lines and the strip off the
    # extra data.

    pkcs7raw = str(pkcs7raw)
    pkcs7raw = re.sub('\\\\n', '\n', pkcs7raw)
    pkcs7raw = pkcs7raw.split('[')[1]
    pkcs7raw = pkcs7raw.split(']')[0].split(',')
    i = 0
    cert_num = 0
    while cert_num < num_requests and i < len(pkcs7raw):
        certstring = str(pkcs7raw[i]).split('"')[1]
        if 'PKCS7' in certstring:
            extract_certs(certstring, arguments)
            cert_num = cert_num + 1
        i = i + 1
    if cert_num != num_requests:
        raise CertificateMismatchException(num_requests, cert_num,
                'Request and certificate received mismatch')
    return


#def create_certificate_request(line, reqid, config_items):
#    """This fucntion accepts hostname, request id and a dictionary of config_items for the CSR.
#    It writes the key and creates the CSR."""
#
#    print 'Generating certificate...'
#    try:
#        keyname = line + '-key.pem'
#        if os.path.exists(keyname):
#            charlimit_textwrap('The key file %s already exists'
#                               % keyname)
#            keyname = line + '-' + str(reqid) + '-key.pem'
#            charlimit_textwrap('Writing key to %s' % keyname)
#    except EOFError, e:
#        charlimit_textwrap('End of File Error: Check if the standard input is enabled\nError %s'
#                            % e)
#        raise e
#    cert_obj = OSGPKIUtils.Cert()
#    cert_obj.CreatePKey(keyname)
#    new_csr = cert_obj.CreateX509Request(**config_items)
#    csr = \
#        new_csr.as_pem().replace('-----BEGIN CERTIFICATE REQUEST-----\n'
#                                 , ''
#                                 ).replace('-----END CERTIFICATE REQUEST-----\n'
#            , '')
#
#    return csr



def process_csr(**arguments):
    """This function handles the entire processing of the request i.e.
    requesting. checking for quota limit, approving and then retrieving in sequence"""
    try:
        arguments = connect_renew(**arguments)
    except Exception, e:
        if 'sslv3 alert bad certificate' in e:
            raise BadCertificateException('Error connecting to server: %s.\n\
                                          Your certificate is not trusted by the server'
                     % e)
        else:
            raise UncaughtException('Uncaught Exception : Please report the bug to goc@opensciencegrid.org.'
                                    )

    #connect_approve(**arguments)
    connect_retrieve(1, **arguments)
    return

def print_uncaught_exception():
    """This function prints the stack trace of a failure to aid
    debugging"""
    print traceback.format_exc()

def process_renew(**arguments):
    """The processing is split into two parts depending upon
    the mode of the request i.e. using a single host request or
    using a file mode. This function handles the processing of a
    single host mode"""
    #config_items = {}
    #config_items.update({'CN': hostname})  # ### New CN for every host#######
    num_requests = 1
    charlimit_textwrap('Beginning request process for %s' % arguments['DN'])
    #csr = create_certificate_request(1,hostname.replace('/', '-'),
    #        config_items)
    process_csr(**arguments)
    return

def get_ssl_context(**arguments):
    """ This function sets the ssl context by accepting the passphrase
    and validating it for user private key and his certificate"""
    first = True
    count = 0
    pass_str = 'Please enter the pass phrase for'
    while(True):
        try:
            def prompt_for_password(verify):
                return getpass.getpass(pass_str+" '%s':"
                                       % arguments['userprivkey'])
        
            ssl_context = M2Crypto.SSL.Context('sslv3')
            ssl_context.load_cert_chain(arguments['usercert'],
                                        arguments['userprivkey'],
                                        callback=prompt_for_password)
            arguments.update({'ssl_context': ssl_context})
            break
        except Exception, e:
            if 'sslv3 alert bad certificate' in e:
                raise BadCertificateException('Error connecting to server: %s.\n\
                                          Your certificate is not trusted by the server'
                 % e)
            elif 'handshake failure' in e:
                raise HanshakeFailureException('Failure: %s.\nPlease check for valid certificate/key pairs.'
                 % e)
            first = False
            count = count + 1
            pass_str = 'Incorrect password. Please enter the password again for'
            if count > 1:
                raise BadPassphraseException('Incorrect passphrase. Attempt failed twice. Exiting script'
                        )
                break
    return arguments

def extract_info(**arguments):
    """ Extracts the DN from the certificate provided."""
    #hostcert = arguments['hostcert']
    x509 = M2Crypto.X509.load_cert(arguments['usercert'])
    #serial_number = float(x509.get_serial_number())
    #print "serial number hex %s" %serial_number#.rstrip("L").lstrip("0x")
    serial_number = subprocess.check_output([
        'openssl',
        'x509',
        '-in',
        os.path.abspath(arguments['usercert']),
        '-serial',
        '-noout',
        ])
    print "serial number" , serial_number
    arguments.update({'serial_number':serial_number})
    DN = x509.get_issuer()
    print "hostname",DN
    arguments.update({'DN':DN})
    return arguments
    
if __name__ == '__main__':
    try:
        os.umask(0177)
        arguments = parse_args()
        print "Parse args"
        arguments = extract_info(**arguments)
        arguments = get_ssl_context(**arguments)
        print "get ssl context done"
        process_renew(**arguments)
    except AttributeError, e:
        print e
        sys.exit()
    except SystemExit, e:
        raise
    except ssl.SSLError, s:
        print s
        sys.exit('Please check for valid certificate.\n')
    except KeyboardInterrupt, k:
        print k
        sys.exit('''Interrupted by user\n''')
    except OSError, e:
        sys.exit(1)
    except Exception_500response, e:
        charlimit_textwrap('Request Failed. Status %s' % e.status)
        charlimit_textwrap('Reason for failure %s' % e.message)
        sys.exit(1)
    except TimeoutException, e:
        charlimit_textwrap('Timeout reached in %s minutes. This script will now exit.'
                            % e.timeout)
        charlimit_textwrap(' You can open goc ticket to track this issue by going to https://ticket.grid.iu.edu\n'
                           )
        sys.exit(1)
    except FileNotFoundException, e:
        charlimit_textwrap(e.message + ':' + e.filename)
        sys.exit(1)
    except ValueError, e:
        sys.exit(1)
    except NotOKException, e:
        charlimit_textwrap('Request Failed. Status %s' % e.status)
        charlimit_textwrap('Reason for failure %s' % e.message)
        sys.exit(1)
    except CertificateMismatchException, e:
        print 'The number of requests made was ', e.request_num
        print 'The number of certificates received is ', e.retrieve_num
        charlimit_textwrap(e.message)
        sys.exit(1)
    except EOFError, e:
        sys.exit(1)
    except BadCertificateException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except BadPassphraseException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except HandshakeFailureException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except QuotaException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except UncaughtException, e:
        print_uncaught_exception()
        charlimit_textwrap(e.message)
        sys.exit(1)
    except UnexpectedBehaviourException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except InsufficientArgumentException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except Exception, e:
        print_uncaught_exception()
        charlimit_textwrap('Uncaught Exception : Please report the bug to goc@opensciencegrid.org.'
                           )
        sys.exit(1)
    sys.exit(0)
