#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
This script submits a host certificate request for an unauthenticated
user.
"""

import urllib
import httplib
import sys
import ConfigParser
import simplejson
import base64
from osgpkitools import OSGPKIUtils
from OSGPKIUtils import CreateOIMConfig
from OSGPKIUtils import charlimit_textwrap
from pprint import pprint
import os
from optparse import OptionParser
import M2Crypto
import textwrap
import traceback
import ssl

# Set up Option Parser
#

def parse_args():
    """This function parses all the arguments, validates them and then stores them in a dictionary that is used throughout the script.\n"""
    parser = OptionParser()
    parser.add_option(
        '-o',
        '--outkeyfile',
        action='store',
        dest='keyfile',
        help='Specify the output filename for the retrieved user certificate. \nDefault is ./hostkey.pem'
            ,
        metavar='Output Keyfile',
        default='./hostkey.pem',
        )
    parser.add_option(
        '-y',
        '--cc',
        action='store',
        dest='cc_list',
        help='Specify the CC list(the email id\'s to be CCed)'
            ,
        metavar='CC List',
        default='',
        )
    parser.add_option(
        '-m',
        '--comment',
        action='store',
        dest='comment',
        help='The comment to be added to the request'
            ,
        metavar='Comment',
        default='',
        )
    parser.add_option(
        '-t',
        '--hostname',
        action='store',
        dest='hostname',
        help='Specify hostname for CSR (FQDN)',
        metavar='CN',
        )
    parser.add_option(
        '-e',
        '--email',
        action='store',
        dest='email',
        help='Email address to receive certificate',
        metavar='EMAIL',
        )
    parser.add_option(
        '-n',
        '--name',
        action='store',
        dest='name',
        help='Name of user receiving certificate',
        metavar='NAME',
        )
    parser.add_option(
        '-p',
        '--phone',
        action='store',
        dest='phone',
        help='Phone number of user receiving certificate',
        metavar='PHONE',
        )
    parser.add_option(
        '-T',
        '--test',
        action='store_true',
        dest='test',
        help='Run in test mode',
        default=False,
        )
    parser.add_option(
        '-q',
        '--quiet',
        action='store_false',
        dest='verbose',
        default=True,
        help="don't print status messages to stdout",
        )
    (args, values) = parser.parse_args()

    if not args.phone:
        parser.error('-p/--phone argument required')
    if not args.name:
        parser.error('-n/--name argument required')
    if not args.email:
        parser.error('-e/--email argument required')
    if not args.hostname:
        parser.error('-t/--hostname argument required')

                        # , config_items

    if os.path.exists(args.keyfile):
        opt = \
            raw_input('%s already exists. Do you want to overwrite it? Y/N : \n'
                       % args.keyfile)
        if opt == 'y' or opt == 'Y':
            pem_filename = args.keyfile
        elif opt == 'n' or opt == 'N':
            pem_filename = \
                raw_input('Please enter a different file name\n')
        else:
            sys.exit('Invalid option')
    else:
        pem_filename = args.keyfile

    hostname = args.hostname
    email = args.email
    name = args.name
    phone = args.phone
    csr = "gennew.csr"
    cc_list = args.cc_list
    comment = args.comment  
    phone_num = phone.replace('-', '')
    if not phone_num.isdigit():
        sys.exit("Phone number should contain only numbers and/or '-'\n"
                 )
    if args.test:
        print "Running in test mode"
        OIM = True
    else:
        OIM = False
    arguments = dict()
    arguments = CreateOIMConfig(OIM, **arguments)
    if vars().has_key('args'):
        arguments.update({'args': args})
    if vars().has_key('values'):
        arguments.update({'values': values})
    if vars().has_key('cc_list'):
        arguments.update({'cc_list': cc_list})
    if vars().has_key('comment'):
        arguments.update({'comment': comment})
    if vars().has_key('pem_filename'):
        arguments.update({'pem_filename': pem_filename})
    arguments.update({'email': email})
    arguments.update({'name': name})
    arguments.update({'phone': phone})
    arguments.update({'hostname': hostname})    
    arguments.update({'csr': csr})
    return arguments


    # Build the connection to the web server - the request header, the parameters
    # needed and then pass them into the server
    #
    # The data returned is in JSON format so to make it a little more human
    # readable we pass it through the json module to pretty print it
    #

def connect(arguments):
    """This function accepts a dictionary consisting of all parameters and their values.\nIt submites the request to the OIM server and returns the request details."""
    print '\nConnecting to server...'
    
    params = urllib.urlencode({
        'name': arguments['name'],
        'email': arguments['email'],
        'phone': arguments['phone'],
        'csrs': arguments['csr'],
        'request_comment' : arguments['comment'],
        'request_ccs' : arguments['cc_list'],
        })
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = httplib.HTTPConnection(arguments['host'])
    try:
        conn.request('POST', arguments['requrl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed: %s' % (arguments['requrl'],
                repr(e)))
        raise e
    except Exception, e:
        charlimit_textwrap('Error during request to %s. Reason %s' \
            % (arguments['requrl'], repr(e)))
    if response.status==500:
        charlimit_textwrap("Request Failed. Status %s" %response.status)
        charlimit_textwrap("Reason for failure %s" %response.reason)
        sys.exit(1)
    data = response.read()
    if 'FAILED' in simplejson.dumps(data):
        reason = simplejson.loads(data)['detail']
        try:
            reason = reason.split('--')[1]
        except IndexError, e:
            reason = reason
        charlimit_textwrap('The request failed because : %s' % reason)
        sys.exit(1)
    conn.close()
    if simplejson.loads(data)['detail'] == 'Nothing to report' \
        and simplejson.loads(data)['status'] == 'OK' in data:
        ticket = simplejson.loads(data)['host_request_id']
        print 'Succesfully submitted'
        print 'Request Id#: %s' % ticket
    return


if __name__ == '__main__':
    try:
        os.umask(177)
        try:
            arguments = parse_args()
        except EOFError, e:
            charlimit_textwrap('End of File Error: Check if the standard input is enabled\nError %s'
                  % e)
            sys.exit(1)
        config_items = {'CN': arguments['hostname'],
                        'emailAddress': arguments['email']}
        cert_obj = OSGPKIUtils.Cert()
        cert_obj.CreatePKey(arguments['pem_filename'])
        print "Writing key to %s" % arguments['pem_filename']
        os.chmod(arguments['pem_filename'],0600)
        new_csr = cert_obj.CreateX509Request(**config_items)
        arguments['csr'] = \
            new_csr.as_pem().replace('-----BEGIN CERTIFICATE REQUEST-----\n'
                , '').replace('-----END CERTIFICATE REQUEST-----\n'
                              , '')
        connect(arguments)
        
    except KeyboardInterrupt, k:
        charlimit_textwrap(k)
        sys.exit('''Interrupted by user\n''')
    except SystemExit, e:
            raise
    except ssl.SSLError, s:
        print s
        sys.exit("Please check for valid certificate.\n")
    except Exception, e:
        print traceback.format_exc()
        charlimit_textwrap('''Uncaught Exception : 
Please report the bug to goc@opensciencegrid.org.
'''
                     )
        sys.exit(1)
    sys.exit(0)
