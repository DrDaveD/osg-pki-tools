#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
This script is used to retrieve certificates. This script requires no
authentication. It will check the status of the request and request
issuance of the certificate if needed (i.e. it is in the APPROVED
state), wait for that issuance to complete, and then retrieve the
certificate.

Not that between requesting a certificate and retrieving it, it is
required for a registration authority to approve the certificate
through the webUI.

This script checks to see if the output file exists and prompts the
user if it does.
"""

import urllib
import httplib
import sys
import ConfigParser
from optparse import OptionParser
import simplejson
import time
import re
import os
import textwrap
import traceback
import subprocess
import ssl
import tempfile

from osgpkitools import OSGPKIUtils
from osgpkitools.OSGPKIUtils import charlimit_textwrap
from osgpkitools.OSGPKIUtils import CreateOIMConfig
from osgpkitools.OSGPKIUtils import extractEEC
from osgpkitools.OSGPKIUtils import extractHostname
from osgpkitools.OSGPKIUtils import check_failed_response
from osgpkitools.OSGPKIUtils import check_response_500
from osgpkitools.OSGPKIUtils import print_failure_reason_exit
from osgpkitools.OSGPKIUtils import check_for_pending
from osgpkitools.OSGPKIUtils import version_info
from osgpkitools.ExceptionDefinitions import *


# Set up Option Parser
#

def parse_args():
    """This function parses all the arguments, validates them and then stores them in a dictionary that is used throughout in the script."""

    usage = \
        'usage: %prog [options] arg\nUsage:%prog -h/--help [for detailed explanations of options]'
    parser = OptionParser(usage)
    parser.add_option(
        '-i',
        '--id',
        action='store',
        dest='id',
        help='Specify ID# of certificate to be retrieved[Required]',
        metavar='ID',
        )
    parser.add_option(
        '-o',
        '--certfile',
        action='store',
        dest='certfile',
        help='Specify the output filename for the retrieved user certificate\n. Default is ./hostcert.pem'
            ,
        metavar='ID',
        default='./hostcert.pem',
        )
    parser.add_option(
        '-T',
        '--test',
        action='store_true',
        dest='test',
        help='Run in test mode',
        default=False,
        )
    parser.add_option(
        '-t',
        '--timeout',
        action='store',
        dest='timeout',
        help='Specify the timeout in minutes',
        default=5,
        )
    parser.add_option(
        '-q',
        '--quiet',
        action='store_false',
        dest='verbose',
        default=True,
        help="don't print status messages to stdout",
        )
    parser.add_option(
        '-V',
        '--version',
        action='store_true',
        dest='version_info',
        help="Print version information and exit",
        )

    (args, values) = parser.parse_args()
    
    #print version info and exit.
    if args.version_info:
        version_info()
        raise SystemExit

    if not args.id:
        parser.error('-i/--id argument required')

    reqid = args.id

    try:
        timeout = int(args.timeout)
        if not timeout >= 0:
            raise ValidationException('Your timeout value cannot be a negative integer.\nExiting now'
                    )
    except ValueError, e:
        charlimit_textwrap('Invalid timeout value. Please enter a non-negative integer.\n'
                           )
        raise e
    print 'Using timeout of %d minutes' % timeout

    if os.path.exists(args.certfile):
        opt = \
            raw_input('The file %s already exists. Do you want to overwrite it? Y/N : \n'
                       % args.certfile)
        if opt == 'y' or opt == 'Y':
            pem_filename = args.certfile
        elif opt == 'n' or opt == 'N':
            pem_filename = \
                raw_input('Please enter a different file name\n')
        else:
            raise InvalidOptionException('Invalid Option')
    else:
        pem_filename = args.certfile
    if args.test:
        OIM = True
    else:
        OIM = False
    
    filetype = 'hostcert'
    fileext = 'pkcs7'
    filename = '%s.%s.%s' % (filetype, reqid, fileext)

    arguments = dict()
    arguments = CreateOIMConfig(OIM, **arguments)
    if vars().has_key('args'):
        arguments.update({'args': args})
    if vars().has_key('values'):
        arguments.update({'values': values})

    if vars().has_key('pem_filename'):
        arguments.update({'pem_filename': pem_filename})
    if vars().has_key('timeout'):
        arguments.update({'timeout': timeout})

    arguments.update({'id': reqid})
    arguments.update({'filetype': filetype})
    arguments.update({'fileext': fileext})
    arguments.update({'filename': filename})
    return arguments


# Build the connection to the web server - the request header, the parameters
# needed and then pass them into the server
#
# The data returned is in JSON format so to make it a little more human
# readable we pass it through the json module to pretty print it
#
# A WHILE loop exists to keep trying to retrieve the certificate if there
# is a delay in issuing
#

def connect_issue(arguments):
    """This function accepts a dictionary of parameters and issues the request if the request is in Approved state."""

    params = urllib.urlencode({'host_request_id': arguments['id']})
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    print 'Contacting Server to initiate certificate issuance. Please wait\n'
    newrequrl = arguments['issurl']
    conn = httplib.HTTPConnection(arguments['host'])
    try:
        conn.request('POST', newrequrl, params, headers)
        time.sleep(10)
        response = conn.getresponse()
    except Exception, e:
        charlimit_textwrap('Connection to %s failed: %s' % (newrequrl,
                           e))
        raise e
    data = response.read()
    conn.close()
    if not 'OK' in data:
        print_failure_reason_exit(data)
    return


# We retrieve the certificate from OIM after it has retrieved it from the CA
# This is where things tend to fall apart - if the delay is to long and the
# request to the CA times out, the whole script operation fails. I'm not
# terribly pleased with that at the moment, but it is out of my hands since
# a GOC staffer has to reset the request to be able to retrieve the
# certificate
#

def connect_retrieve(arguments):
    """This function checks if the request is in Issues state.
    If it is in the issued state, it then retrieves the certificate.
    It accepts a dictionary that consists of all the parameters and their value."""

    iterations = 1
    print 'Connecting server to retrieve certificate...'
    params = urllib.urlencode({'host_request_id': arguments['id']})
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = httplib.HTTPConnection(arguments['host'])
    try:
        conn.request('POST', arguments['returl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed: %s'
                           % (arguments['requrl'], e))
        raise httplib.HTTPException
    check_response_500(response)
    data = response.read()
    if simplejson.loads(data).has_key('request_status'):
        if simplejson.loads(data)['request_status'] == 'REQUESTED':
            raise NotApprovedException('Certificate request is in Requested state.Needs to be Approved first. Please contact GA to approve this certificate\n'
                    )
        else:
            charlimit_textwrap('Certificate request is in Approved state. Needs to be issued first\n'
                               )
            connect_issue(arguments)
    try:
        conn.request('POST', arguments['returl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed: %s'
                           % (arguments['returl'], e))
        raise httplib.HTTPException
    check_response_500(response)
    data = response.read()
    iterations = 0
    while 'PENDING' in data:
        conn.request('POST', arguments['returl'], params, headers)
        try:
            response = conn.getresponse()
        except httplib.HTTPException, e:
            charlimit_textwrap('Connection to %s failed: %s'
                               % (arguments['returl'], e))
            raise httplib.HTTPException
        check_response_500(response)
        data = response.read()
        conn.close()
        iterations = check_for_pending(data, iterations, **arguments)
    check_failed_response(data)
    pkcs7raw = simplejson.loads(data)['pkcs7s'][0]


    # The slice and dice on the JSON output to get the certificate out
    # happens here - the problem is that the new lines are getting all screwy
    # in the output from OIM. We stringify the data, replace all the text
    # newline characters with actual new lines and the strip off the
    # extra data. There's probably a more efficient way to do this, but this
    # was the quick and dirty solution.
    #

    temp_filename = tempfile.NamedTemporaryFile()
    try:
        temp_filename.write(pkcs7raw)
        temp_filename.flush()
        subprocess.call([
            'openssl',
            'pkcs7',
            '-print_certs',
            '-in',
            os.path.abspath(temp_filename.name),
            '-out',
            arguments['pem_filename'],
            ])
        temp_filename.close()
        certString = open(arguments['pem_filename'], 'rb').read()
        hostname = extractHostname(certString)
        extractedEEC = extractEEC(certString, hostname)
        os.remove(arguments['pem_filename'])
        fileWrite = open(arguments['pem_filename'], 'wb')
        fileWrite.write(extractedEEC)
        os.chmod(arguments['pem_filename'], 0644)
    except OSError, e:
        charlimit_textwrap('You may not have permission to write on the file system. \nPlease report the bug to goc@opensciencegrid.org.'
                           )
        raise e
    charlimit_textwrap('Certificate written to %s \n'
                       % arguments['pem_filename'])
    return

def print_uncaught_exception():
    """This function prints the stack trace of the failure to
    aid the debugging of the error."""
    print traceback.format_exc()

if __name__ == '__main__':
    try:
        os.umask(0177)
        arguments = parse_args()
        path = os.getcwd()
        check_permissions(path)
        connect_retrieve(arguments)
    except EOFError, e:
        charlimit_textwrap('End of File Error: Check if the standard input is enabled\nError %s'
                            % e)
        sys.exit(1)
    except SystemExit, e:
        raise
    except KeyboardInterrupt, k:
        charlimit_textwrap(k)
        sys.exit('''Interrupted by user\n''')
    except ssl.SSLError, s:
        print s
        sys.exit('Please check for valid certificate.\n')
    except Exception_500response, e:
        charlimit_textwrap('Request Failed. Status %s' % e.status)
        charlimit_textwrap('Reason for failure %s' % e.message)
        sys.exit(1)
    except TimeoutException, e:
        charlimit_textwrap('Timeout reached in %s minutes. This script will now exit.'
                            % e.timeout)
        charlimit_textwrap(' You can open goc ticket to track this issue by going to https://ticket.grid.iu.edu\n'
                           )
        sys.exit(1)
    except FileWriteException, e:
        charlimit_textwrap(e.message)
        charlimit_textwrap("The script will exit now\n")
        sys.exit(1)
    except FileNotFoundException, e:
        charlimit_textwrap(e.message + ':' + e.filename)
        sys.exit(1)
    except ValueError, e:
        sys.exit(1)
    except NotOKException, e:
        charlimit_textwrap('Request Failed. Status %s' % e.status)
        charlimit_textwrap('Reason for failure %s' % e.message)
        sys.exit(1)
    except ValidationException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except InvalidOptionException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except UncaughtException, e:
        print_uncaught_exception()
        charlimit_textwrap(e.message)
        sys.exit(1)
    except NotApprovedException, e:
        charlimit_textwrap(e.message)
    except OSError, e:
        sys.exit(1)
    except UnexpectedBehaviourException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except Exception, e:
        print_uncaught_exception()
        charlimit_textwrap('Uncaught Exception : Please report the bug to goc@opensciencegrid.org.'
                           )
        sys.exit(1)
    sys.exit(0)
