#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
This script is used to submit multiple certifcate requests and
the intended user for the script is the GridAdmin.
This script requests certificates and then approves as well as issues them
in bulk (limit of 50 at a time).
This script works in two modes:
1) Requesting single host certificate with -H option
2) Request multiple host certificates with hostnames stored in a file -f option
"""

import pdb
import urllib
import httplib
import sys
import ConfigParser
import simplejson
import time
import re
import os
import errno
import getpass
import StringIO
import base64
import M2Crypto
from optparse import OptionParser
from optparse import OptionGroup
import optparse
import sys
import textwrap
import traceback
import subprocess
import ssl
import tempfile

from osgpkitools import OSGPKIUtils
from osgpkitools.OSGPKIUtils import CreateOIMConfig
from osgpkitools.OSGPKIUtils import extractHostname
from osgpkitools.OSGPKIUtils import extractEEC
from osgpkitools.OSGPKIUtils import get_request_count
from osgpkitools.OSGPKIUtils import check_response_500
from osgpkitools.OSGPKIUtils import check_failed_response
from osgpkitools.OSGPKIUtils import print_failure_reason_exit
from osgpkitools.OSGPKIUtils import check_for_pending
from osgpkitools.OSGPKIUtils import charlimit_textwrap
from osgpkitools.ExceptionDefinitions import *


# Set up Option Parser
#

def parse_args():
    """This function parses all the arguments, validates them and then stores them
    in a dictionary that is used throughout the script."""

    usage = \
        'usage: %prog [options] arg\nUsage:%prog -h/--help [for detailed explanations of options]'
    parser = OptionParser(usage)
    group = OptionGroup(parser, 'Hostname Options',
                        '''Use either of these options.
Specify hostname as a single hostname using -H/--hostname
or specify from a file using -f/--hostfile.''')
    parser.add_option(
        '-k',
        '--pkey',
        action='store',
        dest='userprivkey',
        help="Specify Requestor's private key (PEM Format).\n If not specified\
             will take the value of X509_USER_KEY or $HOME/.globus/userkey.pem"
            ,
        metavar='PKEY',
        default=None,
        )
    parser.add_option(
        '-c',
        '--cert',
        action='store',
        dest='usercert',
        help="Specify Requestor's certificate (PEM Format).\n If not specified\
             will take the value of X509_USER_CERT or $HOME/.globus/usercert.pem"
            ,
        default=None,
        metavar='CERT',
        )
    group.add_option(
        '-H',
        '--hostname',
        action='store',
        dest='hostname',
        help='Specify the hostname or service/hostname for which you want to request\
             the certificate for.\n If specified -f/--hostfile will be ignored'
            ,
        metavar='HOSTNAME',
        )
    group.add_option(
        '-f',
        '--hostfile',
        action='store',
        dest='hostfile',
        help='Filename with one hostname or service/hostname per line',
        metavar='HOSTFILE',
        default=None,
        )
    parser.add_option(
        '-v',
        '--vo',
        action='store',
        dest='vo',
        help='Specify the VO for the host request'
            ,
        metavar='VO name',
        default=None,
        )
    parser.add_option(
        '-T',
        '--test',
        action='store_true',
        dest='test',
        help='Run in test mode',
        default=False,
        )
    parser.add_option(
        '-t',
        '--timeout',
        action='store',
        dest='timeout',
        help='Specify the timeout in minutes',
        default=5,
        )
    parser.add_option(
        '-q',
        '--quiet',
        action='store_false',
        dest='verbose',
        default=True,
        help="don't print status messages to stdout",
        )
    parser.add_option_group(group)
    (args, values) = parser.parse_args()
    arguments = dict()
    if not args.hostname:
        if args.hostfile is None:
            raise InsufficientArgumentException("InsufficientArgumentException: \
                                                Please provide hostname(-H) or file name containing hosts(-f)\n\
                               Use osg-gridadmin-cert-request -h for help")
        else:
            hostfile = args.hostfile
    else:
        hostname = args.hostname

    try:
        timeout = int(args.timeout)
        if not timeout >= 0:
            charlimit_textwrap('Your timeout value cannot be a negative integer.\nExiting now'
                               )
            raise ValueError
    except ValueError:
        raise ValueError('Invalid timeout value. Please enter a non-negative integer value.\n'
                         )
    print 'Using timeout of %d minutes' % timeout

    certdir = './'

    if args.userprivkey is None:
        try:
            userprivkey = os.environ['X509_USER_KEY']
        except:
            if os.path.exists(str(os.environ['HOME'])
                              + '/.globus/userkey.pem'):
                userprivkey = str(os.environ['HOME']) \
                    + '/.globus/userkey.pem'
            else:
                raise FileNotFoundException('Key file',
                        'Could not locate the private key file')
    else:
        userprivkey = args.userprivkey

    if os.path.exists(userprivkey):
        pass
    else:
        raise FileNotFoundException(userprivkey,
                                    'Could not locate the private key file'
                                    )
    if args.usercert is None:
        try:
            usercert = os.environ['X509_USER_CERT']
        except:
            usercert = str(os.environ['HOME']) + '/.globus/usercert.pem'
            if os.path.exists(str(os.environ['HOME'])
                              + '/.globus/usercert.pem'):
                usercert = str(os.environ['HOME']) \
                    + '/.globus/usercert.pem'
            else:
                raise FileNotFoundException('Certificate File',
                        'Could not locate the certificate file')
    else:
        usercert = args.usercert

    if os.path.exists(usercert):
        pass
    else:
        raise FileNotFoundException(usercert,
                                    'Could not locate the certificate file'
                                    )
    if not args.hostname:
        if os.path.exists(hostfile):
            pass
        else:
            raise FileNotFoundException(hostfile,
                    'Could not locate the hostfile')
    if args.test:
        OIM = True
    else:
        OIM = False
    arguments.update({'vo' : args.vo})
    arguments.update({'mode': OIM})
    arguments = CreateOIMConfig(OIM, **arguments)
    if vars().has_key('args'):
        arguments.update({'args': args})
    if vars().has_key('values'):
        arguments.update({'values': values})
    if vars().has_key('hostname'):
        arguments.update({'hostname': hostname})
    if vars().has_key('domain'):
        arguments.update({'domain': domain})
    if vars().has_key('outkeyfile'):
        arguments.update({'outkeyfile': outkeyfile})
    if vars().has_key('timeout'):
        arguments.update({'timeout': timeout})
        print 'The timeout is set to %s' % arguments['timeout']
    if vars().has_key('num_requests'):
        arguments.update({'num_requests': num_requests})
    arguments.update({'usercert': usercert})
    arguments.update({'userprivkey': userprivkey})
    arguments.update({'certdir': certdir})
    if vars().has_key('hostfile'):
        arguments.update({'hostfile': hostfile})
    arguments.update({'host': arguments['hostsec']})
    return arguments


#################################################

# We make the request here, causing the generation of the CSR and then
# pass the ID returned from the server along. The ID is the key that OIM
# uses for all certificate operations via the API
#

def connect_request(bulk_csr, **arguments):
    """This function accepts a an ssl_context instance which contains information about the established ssl connection,
    the csr string(base64 encoded) and a dictionary consisting of all parameters and their values,
    It submits the request to the OIM server and returns the request details.
    """

    print 'Connecting to server to request certificate...'
    params = urllib.urlencode({'csrs': bulk_csr,
                               'vo' : arguments['vo']}, doseq=True)
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = M2Crypto.httpslib.HTTPSConnection(arguments['hostsec'],
            ssl_context=arguments['ssl_context'])
    try:
        conn.request('POST', arguments['requrl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed : %s' % (requrl, e))
        raise e
    data = response.read()
    #This if block is to catch failures and would exit the script
    if not 'OK' in response.reason:
        print_failure_reason_exit(data)
    conn.close()
    check_failed_response(data)
    return_data = simplejson.loads(data)
    for (key, value) in return_data.iteritems():
        if 'host_request_id' in key:
            reqid = value
            print 'Id is:', reqid
    if not reqid:
        raise UnexpectedBehaviourException("Request Id not found in data. Script will not exit")
    arguments.update({'reqid': reqid})
    return arguments


# ID from the request is passed in here via secure connection and the request
# gets approved automatically since it's a bulk request. We also issue the
# certificate (i.e. OIM contacts the CA on our behalf to get the cert) in this
# function
#

def connect_approve(**arguments):
    """This function accepts an ssl_context instance which contains information about the established ssl connection
    and a dictionary consisting of all parameters and their values,
    It approves the request that is submitted to the OIM by connect_request.
    """

    print 'Connecting to server to approve certificate...'
    params = urllib.urlencode({'host_request_id': arguments['reqid']})
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = M2Crypto.httpslib.HTTPSConnection(arguments['host'],
            ssl_context=arguments['ssl_context'])
    try:
        conn.request('POST', arguments['appurl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed: %s'
                           % (arguments['appurl'], repr(e)))
        raise e
    except AttributeError, e:
        raise e
    check_response_500(response)
    if not 'OK' in response.reason:
        raise NotOKException(response.status, response.reason)
    data = response.read()
    conn.close()
    issurl = arguments['issurl']
    if 'OK' in data:
        print 'Contacting Server to initiate certificate issuance.'
        newrequrl = arguments['issurl']
        conn = M2Crypto.httpslib.HTTPSConnection(arguments['host'],
                ssl_context=arguments['ssl_context'])
        try:
            conn.request('POST', newrequrl, params, headers)
            response = conn.getresponse()
        except httplib.HTTPException, e:
            charlimit_textwrap('Connection to %s failed: %s'
                               % (newrequrl, e))
            raise e
        data = response.read()
        conn.close()
        check_failed_response(data)
    else:
        raise NotOKException('Failed', simplejson.loads(data)['detail'])
    #elif not 'OK' in data:
    #    raise NotOKException('Failed', simplejson.loads(data)['detail'])

# Here's where things have gotten dicey during the testing phase -
# We retrieve the certificate from OIM after it has retrieved it from the CA
# This is where things tend to fall apart - if the delay is to long and the
# request to the CA times out, the whole script operation fails. I'm not
# terribly pleased with that at the moment, but it is out of my hands since
# a GOC staffer has to reset the request to be able to retrieve the
# certificate
#

def extract_certs(pkcs7raw, arguments):
    """This function accepts the hostname, pkcs7raw dump of the certificate and
    a dictionary that consists variables and their value against them.
    It write the certificates to file system by calling write_certificate function"""
    pkcs7_file = tempfile.NamedTemporaryFile()
    pkcs7_file.write(str(pkcs7raw))
    pkcs7_file.flush()
    temp_file = tempfile.NamedTemporaryFile()
    print ''

    # ### printing our all the certificates received from OIM to a temporrary file###
    subprocess.call([
        'openssl',
        'pkcs7',
        '-print_certs',
        '-in',
        os.path.abspath(pkcs7_file.name),
        '-out',
        os.path.abspath(temp_file.name),
        ])
    pkcs7_file.close()
    certString = temp_file.read()
    temp_file.close()
    # ## Extracting the hostname ###

    hostname = extractHostname(certString)

    # ## Extracting the EEC certificate ###

    eecString = extractEEC(certString, hostname)
    arguments.update({'hostname': hostname})
    arguments.update({'eecString': eecString})
    write_certificate(**arguments)
    return


def write_certificate(**arguments):
    """ This function writes the extracted EEC certificate"""
    hostname = arguments['hostname']
    eecString = arguments['eecString']
    hostname = hostname.strip(' \n').replace('/', '-')
    pem_filename = hostname + '.pem'
    temp_file = tempfile.NamedTemporaryFile()
    temp_file.write(eecString)
    temp_file.flush()
    if os.path.exists(pem_filename):
        charlimit_textwrap('The file %s already exists.' % pem_filename)
        pem_filename = '%s-%s.%s' % (hostname, arguments['reqid'], 'pem'
                )
    subprocess.call(['cp', os.path.abspath(temp_file.name), pem_filename])  # ## fix for move the file to desired name ###
    os.chmod(pem_filename, 0644)
    cwd = os.getcwd()
    try:
        os.chdir(arguments['certdir'])
    except OSError, e:
        charlimit_textwrap('''The directory %s does not exist or you cannot access the directory
    .Please report the bug to goc@opensciencegrid.org.a
    %s''',
                           arguments['certdir'], e)
        raise OSError
    os.chdir(cwd)
    charlimit_textwrap('''Certificate written to %s%s 
    '''
                       % (arguments['certdir'], pem_filename))
    temp_file.close()
    return


def connect_retrieve(num_requests, **arguments):
    """This fucntion accepts a dictionary consisting of variables and their values against it.
    It retrieves the certificate from the OIM."""

    iterations = 1
    print 'Issuing certificate...'
    params = urllib.urlencode({'host_request_id': arguments['reqid']})
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = httplib.HTTPSConnection(arguments['host'])
    try:
        conn.request('POST', arguments['returl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed: %s' % (newurl, e))
        raise httplib.HTTPException
    check_response_500(response)
    data = response.read()
    if not 'PENDING' in response.reason:
        if not 'OK' in response.reason:
            print_failure_reason_exit(data)
    conn.close()
    charlimit_textwrap('Waiting for response from Certificate Authority. Please wait.'
                       )
    iterations = 0
    while 'PENDING' in data:
        conn.request('POST', arguments['returl'], params, headers)
        try:
            response = conn.getresponse()
        except httplib.HTTPException, e:
            charlimit_textwrap('Connection to %s failed: %s' % (newurl,
                               e))
            raise httplib.HTTPException
        check_response_500(response)
        data = response.read()
        conn.close()
        iterations = check_for_pending(data, iterations, **arguments)
    pkcs7raw = simplejson.dumps(simplejson.loads(data), sort_keys=True,
                                indent=2)
    check_failed_response(data)

    # The slice and dice on the JSON output to get the certificate out
    # happens here - the problem is that the new lines are getting all screwy
    # in the output from OIM. We stringify the data, replace all the text
    # newline characters with actual new lines and the strip off the
    # extra data.

    pkcs7raw = str(pkcs7raw)
    pkcs7raw = re.sub('\\\\n', '\n', pkcs7raw)
    pkcs7raw = pkcs7raw.split('[')[1]
    pkcs7raw = pkcs7raw.split(']')[0].split(',')
    i = 0
    cert_num = 0
    while cert_num < num_requests and i < len(pkcs7raw):
        certstring = str(pkcs7raw[i]).split('"')[1]
        if 'PKCS7' in certstring:
            extract_certs(certstring, arguments)
            cert_num = cert_num + 1
        i = i + 1
    if cert_num != num_requests:
        raise CertificateMismatchException(num_requests, cert_num,
                'Request and certificate received mismatch')
    return


def create_certificate_request(line, reqid, config_items):
    """This fucntion accepts hostname, request id and a dictionary of config_items for the CSR.
    It writes the key and creates the CSR."""

    print 'Generating certificate...'
    try:
        keyname = line + '-key.pem'
        if os.path.exists(keyname):
            charlimit_textwrap('The key file %s already exists'
                               % keyname)
            keyname = line + '-' + str(reqid) + '-key.pem'
            charlimit_textwrap('Writing key to %s' % keyname)
    except EOFError, e:
        charlimit_textwrap('End of File Error: Check if the standard input is enabled\nError %s'
                            % e)
        raise e
    cert_obj = OSGPKIUtils.Cert()
    cert_obj.CreatePKey(keyname)
    new_csr = cert_obj.CreateX509Request(**config_items)
    csr = \
        new_csr.as_pem().replace('-----BEGIN CERTIFICATE REQUEST-----\n'
                                 , ''
                                 ).replace('-----END CERTIFICATE REQUEST-----\n'
            , '')

    return csr


def check_quota_limit(request_count, arguments):
    '''This function checks if the quota requirements for the user is met for the particular request'''

    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = M2Crypto.httpslib.HTTPSConnection(arguments['host'],
            ssl_context=arguments['ssl_context'])
    try:
        conn.request('GET', arguments['quotaurl'], None, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        charlimit_textwrap('Connection to %s failed: %s'
                           % (arguments['quotaurl'], e))
        raise httplib.HTTPException
    except Exception, e:
        if "sslv3 alert bad certificate" in e:
            raise BadCertificateException('Error connecting to server: %s.\n\
                                          Your certificate is not trusted by the server'
                 % e)
        else:
            raise UncaughtException
    check_response_500(response)
    data = response.read()
    if not 'PENDING' in response.reason:
        if not 'OK' in response.reason:
            print_failure_reason_exit(data)
    charlimit_textwrap('Waiting for response from Quota Check API. Please wait.'
                       )
    iterations = 0
    while 'PENDING' in data:
        conn.request('GET', arguments['quotaurl'], headers)
        try:
            response = conn.getresponse()
        except httplib.HTTPException, e:
            charlimit_textwrap('Connection to %s failed: %s'
                               % (arguments['quotaurl'], e))
            raise httplib.HTTPException
        check_response_500(response)
        data = response.read()
        conn.close()
        iterations = check_for_pending(data, iterations, **arguments)
    check_failed_response(data)
    global_hostcert_year_max = \
        simplejson.loads(data)['global_hostcert_year_max']
    global_hostcert_year_count = \
        simplejson.loads(data)['global_hostcert_year_count']
    count_hostcert_day = simplejson.loads(data)['count_hostcert_day']
    quota_hostcert_day_max = \
        simplejson.loads(data)['quota_hostcert_day_max']
    count_hostcert_year = simplejson.loads(data)['count_hostcert_year']
    quota_hostcert_year_max = \
        simplejson.loads(data)['quota_hostcert_year_max']
    if global_hostcert_year_max >= global_hostcert_year_count \
        + request_count and count_hostcert_day + request_count \
        <= quota_hostcert_day_max and count_hostcert_year \
        + request_count <= quota_hostcert_year_max \
        and quota_hostcert_day_max >= request_count:
        status = True
    else:
        status = False
    conn.close()
    return status


def process_csr(num_requests, bulk_csr, **arguments):
    """This function handles the entire processing of the request i.e.
    requesting. checking for quota limit, approving and then retrieving in sequence"""
    try:
        arguments = connect_request(bulk_csr, **arguments)
    except Exception, e:
        if 'sslv3 alert bad certificate' in e:
            raise BadCertificateException('Error connecting to server: %s.\n\
                                          Your certificate is not trusted by the server'
                     % e)
        else:
            raise UncaughtException('Uncaught Exception : Please report the bug to goc@opensciencegrid.org.'
                                    )

    connect_approve(**arguments)
    connect_retrieve(num_requests, **arguments)
    return

def print_uncaught_exception():
    """This function prints the stack trace of a failure to aid
    debugging"""
    print traceback.format_exc()

def process_single_host_mode(**arguments):
    """The processing is split into two parts depending upon
    the mode of the request i.e. using a single host request or
    using a file mode. This function handles the processing of a
    single host mode"""
    bulk_csr = list()
    count = 0
    num_requests = 0
    host_set = set()
    config_items = {}
    status = check_quota_limit(1, arguments)
    if status:
        pass
    else:
        raise QuotaException('Your request would exceed your quota. Aborting'
                             )
    hostname = arguments['hostname'].rstrip('\n')
    config_items.update({'CN': hostname})  # ### New CN for every host#######
    num_requests = 1
    charlimit_textwrap('Beginning request process for %s' % hostname)
    csr = create_certificate_request(hostname.replace('/', '-'), count,
            config_items)
    process_csr(1, csr, **arguments)
    return


def process_hostfile_mode(**arguments):
    """The processing is split into two parts depending upon
    the mode of the request i.e. using a single host request or
    using a file mode. This function handles the processing of a
    hostfile mode"""
    
    bulk_csr = list()
    count = 0
    num_requests = 0
    host_set = set()
    config_items = {}
    hosts = open(arguments['hostfile'], 'rb')
    request_count = get_request_count(arguments['hostfile'])
    status = check_quota_limit(request_count, arguments)
    if status:
        pass
    else:
        raise QuotaException('Your request would exceed your quota. Aborting'
                             )
    for line in hosts:
        line = line.strip(' \n')
        if not line in host_set:
            host_set.add(line)
            count += 1  # ## as a check for number of request and certs retrieved ###
            config_items.update({'CN': line})  # ### New Config item list for every host#######
            charlimit_textwrap('Beginning request process for %s'
                               % line)
            csr = create_certificate_request(line.replace('/', '-'),
                    count, config_items)
            bulk_csr.append(csr)
            num_requests = num_requests + 1  # ## as a check for number of request and certs retrieved ###
            if count == 50:  # ## Processing max of 50 requests in bulk ###
                process_csr(request_count, bulk_csr, **arguments)
                bulk_csr = ''
                count = 0
        else:
            charlimit_textwrap('''Duplicate Hostname entry for %s.
Skipping process for %s
'''
                               % (line, line))
    if count != 0 and count != 50:
        process_csr(request_count, bulk_csr, **arguments)
    hosts.close()
    return


def get_ssl_context(**arguments):
    """ This function sets the ssl context by accepting the passphrase
    and validating it for user private key and his certificate"""
    first = True
    count = 0
    pass_str = 'Please enter the pass phrase for'
    while(True):
        try:
            def prompt_for_password(verify):
                return getpass.getpass(pass_str+" '%s':"
                                       % arguments['userprivkey'])
        
            ssl_context = M2Crypto.SSL.Context('sslv3')
            ssl_context.load_cert_chain(arguments['usercert'],
                                        arguments['userprivkey'],
                                        callback=prompt_for_password)
            arguments.update({'ssl_context': ssl_context})
            break
        except Exception, e:
            if 'sslv3 alert bad certificate' in e:
                raise BadCertificateException('Error connecting to server: %s.\n\
                                          Your certificate is not trusted by the server'
                 % e)
            elif 'handshake failure' in e:
                raise HanshakeFailureException('Failure: %s.\nPlease check for valid certificate/key pairs.'
                 % e)
            first = False
            count = count + 1
            pass_str = 'Incorrect password. Please enter the password again for'
            if count > 1:
                raise BadPassphraseException('Incorrect passphrase. Attempt failed twice. Exiting script'
                        )
                break
    return arguments


if __name__ == '__main__':
    try:
        os.umask(0177)
        arguments = parse_args()
        #if not arguments.has_key('ssl_context'):
        arguments = get_ssl_context(**arguments)
        if not arguments.has_key('hostname'):
            process_hostfile_mode(**arguments)
        else:
            process_single_host_mode(**arguments)
    except AttributeError, e:
        print e
        sys.exit()
    except SystemExit, e:
        raise
    except ssl.SSLError, s:
        print s
        sys.exit('Please check for valid certificate.\n')
    except KeyboardInterrupt, k:
        print k
        sys.exit('''Interrupted by user\n''')
    except OSError, e:
        sys.exit(1)
    except Exception_500response, e:
        charlimit_textwrap('Request Failed. Status %s' % e.status)
        charlimit_textwrap('Reason for failure %s' % e.message)
        sys.exit(1)
    except TimeoutException, e:
        charlimit_textwrap('Timeout reached in %s minutes. This script will now exit.'
                            % e.timeout)
        charlimit_textwrap(' You can open goc ticket to track this issue by going to https://ticket.grid.iu.edu\n'
                           )
        sys.exit(1)
    except FileNotFoundException, e:
        charlimit_textwrap(e.message + ':' + e.filename)
        sys.exit(1)
    except ValueError, e:
        sys.exit(1)
    except NotOKException, e:
        charlimit_textwrap('Request Failed. Status %s' % e.status)
        charlimit_textwrap('Reason for failure %s' % e.message)
        sys.exit(1)
    except CertificateMismatchException, e:
        print 'The number of requests made was ', e.request_num
        print 'The number of certificates received is ', e.retrieve_num
        charlimit_textwrap(e.message)
        sys.exit(1)
    except EOFError, e:
        sys.exit(1)
    except BadCertificateException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except BadPassphraseException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except HandshakeFailureException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except QuotaException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except UncaughtException, e:
        print_uncaught_exception()
        charlimit_textwrap(e.message)
        sys.exit(1)
    except UnexpectedBehaviourException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except InsufficientArgumentException, e:
        charlimit_textwrap(e.message)
        sys.exit(1)
    except Exception, e:
        print_uncaught_exception()
        charlimit_textwrap('Uncaught Exception : Please report the bug to goc@opensciencegrid.org.'
                           )
        sys.exit(1)
    sys.exit(0)
