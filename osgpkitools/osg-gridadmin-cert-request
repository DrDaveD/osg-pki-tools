#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
This script is used to submit multiple certifcate requests and
the intended user for the script is the GridAdmin.
This script requests certificates and then approves as well as issues them
in bulk (limit of 50 at a time).
This script works in two modes:
1) Requesting single host certificate with -H option
2) Request multiple host certificates with hostnames stored in a file -f option
"""

import httplib
import re
import sys
import os
import subprocess
import tempfile

from ssl import SSLError
from optparse import OptionParser, OptionGroup
from M2Crypto import SSL

from osgpkitools import OSGPKIUtils
from osgpkitools.OSGPKIUtils import read_config
from osgpkitools.OSGPKIUtils import extractHostname
from osgpkitools.OSGPKIUtils import extractEEC
from osgpkitools.OSGPKIUtils import version_info
from osgpkitools.OSGPKIUtils import check_permissions
from osgpkitools.OSGPKIUtils import charlimit_textwrap
from osgpkitools.OSGPKIUtils import print_exception_message
from osgpkitools.OSGPKIUtils import print_uncaught_exception
from osgpkitools.OSGPKIUtils import get_ssl_context
from osgpkitools.ExceptionDefinitions import *
from osgpkitools import ConnectAPI


# Set up Option Parser
#

def parse_args():
    """This function parses all the arguments, validates them and then stores them
    in a dictionary that is used throughout the script."""

    usage = \
        'usage: %prog [options] arg\nUsage: %prog -h/--help [for detailed explanations of options]'
    parser = OptionParser(usage)
    group = OptionGroup(parser, 'Hostname Options',
                        '''Use either of these options.
Specify hostname as a single hostname using -H/--hostname
or specify from a file using -f/--hostfile.''')
    parser.add_option(
        '-k',
        '--pkey',
        action='store',
        dest='userprivkey',
        help="Specify Requestor's private key (PEM Format). If not specified" + \
             "will take the value of X509_USER_KEY or $HOME/.globus/userkey.pem",
        metavar='PKEY',
        default=None,
        )
    parser.add_option(
        '-c',
        '--cert',
        action='store',
        dest='usercert',
        help="Specify Requestor's certificate (PEM Format). If not specified, " + \
        "will take the value of X509_USER_CERT or $HOME/.globus/usercert.pem",
        default=None,
        metavar='CERT',
        )
    group.add_option(
        '-H',
        '--hostname',
        action='store',
        dest='hostname',
        help='Specify the hostname or service/hostname for which you want to request ' + \
        'the certificate for. If specified, -f/--hostfile will be ignored',
        metavar='HOSTNAME',
        default=None,
        )
    parser.add_option(
        '-a',
        '--altname',
        action='append',
        dest='alt_names',
        help='Specify an alternative hostname for CSR (FQDN). May be used more than ' + \
        'once and if specified, -f/--hostfile will be ignored',
        metavar='HOSTNAME',
        default=[]
        )
    group.add_option(
        '-f',
        '--hostfile',
        action='store',
        dest='hostfile',
        help='Filename with one host (hostname or service/hostname and its optional,' + \
        'alternative hostnames, separated by spaces) per line',
        metavar='HOSTFILE',
        default=None,
        )
    parser.add_option(
        '-v',
        '--vo',
        action='store',
        dest='vo',
        help='Specify the VO for the host request',
        metavar='VO name',
        default=None,
        )
    parser.add_option(
        '-y',
        '--cc',
        action='store',
        dest='cc_list',
        help='Specify the CC list(the email id\'s to be CCed).' + \
             'Separate values by \',\'',
        metavar='CC List',
        default='',
        )
    parser.add_option(
        '-T',
        '--test',
        action='store_true',
        dest='test',
        help='Run in test mode',
        default=False,
        )
    parser.add_option(
        '-t',
        '--timeout',
        action='store',
        dest='timeout',
        help='Specify the timeout in minutes',
        default=5,
        )
    parser.add_option(
        '-q',
        '--quiet',
        action='store_false',
        dest='verbose',
        default=True,
        help="don't print status messages to stdout",
        )
    parser.add_option(
        '-d',
        '--directory',
        action='store',
        dest='write_directory',
        help="Write the output files to this directory",
        )
    parser.add_option(
        '-V',
        '--version',
        action='store_true',
        dest='version_info',
        help="Print version information and exit",
        )
    parser.add_option_group(group)
    (args, values) = parser.parse_args()

    if args.version_info:
        version_info()
        sys.exit(0)

    if not args.hostname:
        if args.hostfile is None:
            raise InsufficientArgumentException("InsufficientArgumentException: " + \
                                                "Please provide hostname(-H) or file name containing hosts(-f)\n")
        else:
            hostfile = args.hostfile
    else:
        hostname = args.hostname

    timeout = int(args.timeout)
    if not timeout >= 0:
        raise ValueError('Invalid timeout value. Please enter a non-negative integer value.\n')

    if args.write_directory:
        certdir = args.write_directory
        charlimit_textwrap("Writing certificate to %s" %certdir)

    else:
        certdir = './'

    if args.userprivkey is None:
        try:
            userprivkey = os.environ['X509_USER_KEY']
        except KeyError:
            if os.path.exists(str(os.environ['HOME'])
                              + '/.globus/userkey.pem'):
                userprivkey = str(os.environ['HOME']) \
                    + '/.globus/userkey.pem'
            else:
                raise FileNotFoundException('Key file', 'Could not locate the private key file')
    else:
        userprivkey = args.userprivkey

    if os.path.exists(userprivkey):
        pass
    else:
        raise FileNotFoundException(userprivkey, 'Could not locate the private key file')
    if args.usercert is None:
        try:
            usercert = os.environ['X509_USER_CERT']
        except KeyError:
            usercert = str(os.environ['HOME']) + '/.globus/usercert.pem'
            if os.path.exists(str(os.environ['HOME'])
                              + '/.globus/usercert.pem'):
                usercert = str(os.environ['HOME']) \
                    + '/.globus/usercert.pem'
            else:
                raise FileNotFoundException('Certificate File', 'Could not locate the certificate file')
    else:
        usercert = args.usercert

    if os.path.exists(usercert):
        pass
    else:
        raise FileNotFoundException(usercert, 'Could not locate the certificate file')

    if not args.hostname:
        if os.path.exists(hostfile):
            pass
        else:
            raise FileNotFoundException(hostfile, 'Could not locate the hostfile')
    if args.test:
        oim = True
    else:
        oim = False

    arguments = read_config(oim)
    arguments.update({'vo' : args.vo})
    arguments.update({'mode': oim})
    arguments.update({'cc_list': args.cc_list})
    if vars().has_key('args'):
        arguments.update({'args': args})
    if vars().has_key('values'):
        arguments.update({'values': values})
    if vars().has_key('hostname'):
        arguments.update({'hostname': hostname})
    arguments.update({'timeout': timeout})
    print 'Using timeout of %d minutes' % timeout
    arguments.update({'alt_names': args.alt_names})
    arguments.update({'usercert': usercert})
    arguments.update({'userprivkey': userprivkey})
    arguments.update({'certdir': certdir})
    if vars().has_key('hostfile'):
        arguments.update({'hostfile': hostfile})
    return arguments


#################################################



def extract_certs(pkcs7raw, **arguments):
    """This function accepts the hostname, pkcs7raw dump of the certificate and
    a dictionary that consists variables and their value against them.
    It write the certificates to file system by calling write_certificate function"""
    pkcs7_file = tempfile.NamedTemporaryFile()
    pkcs7_file.write(str(pkcs7raw))
    pkcs7_file.flush()
    temp_file = tempfile.NamedTemporaryFile()
    print ''

    # ### printing our all the certificates received from OIM to a temporary file###
    subprocess.call([
        'openssl',
        'pkcs7',
        '-print_certs',
        '-in',
        os.path.abspath(pkcs7_file.name),
        '-out',
        os.path.abspath(temp_file.name),
        ])
    pkcs7_file.close()
    cert_string = temp_file.read()
    temp_file.close()
    ### Extracting the hostname ###

    hostname = extractHostname(cert_string)

    ### Extracting the EEC certificate ###

    eec_string = extractEEC(cert_string, hostname)
    arguments.update({'hostname': hostname})
    arguments.update({'eecString': eec_string})
    write_certificate(**arguments)


def write_certificate(**arguments):
    """ This function writes the extracted EEC certificate"""
    cwd = os.getcwd()
    try:
        os.chdir(arguments['certdir'])
        os.getcwd()
    except OSError, exc:
        charlimit_textwrap('''The directory %s does not exist or you cannot access the directory
        . Please report the bug to goc@opensciencegrid.org.
        %s''' % (arguments['certdir'], exc))
        raise
    hostname = arguments['hostname']
    eec_string = arguments['eecString']
    hostname = hostname.strip(' \n').replace('/', '-')
    pem_filename = hostname + '.pem'
    temp_file = tempfile.NamedTemporaryFile()
    temp_file.write(eec_string)
    temp_file.flush()
    if os.path.exists(pem_filename): ###Fix for already existing cert file ###

        #charlimit_textwrap('The file %s already exists.' % pem_filename)
        old_pem_filename = hostname + "-old.pem"
        subprocess.call(['mv', pem_filename, old_pem_filename])
        print "Renaming existing file from %s to %s" % (os.path.join(arguments['certdir'], pem_filename),
                                                        os.path.join(arguments['certdir'], old_pem_filename))
        #pem_filename = '%s-%s.%s' % (hostname, arguments['reqid'], 'pem'
                #)
    subprocess.call(['cp', os.path.abspath(temp_file.name), pem_filename])  ### fix for move the file to desired name ###
    os.chmod(pem_filename, 0644)

    os.chdir(cwd)
    charlimit_textwrap('Certificate written to %s' % os.path.join(arguments['certdir'], pem_filename))
    temp_file.close()
    return

    # The slice and dice on the JSON output to get the certificate out
    # happens here - the problem is that the new lines are getting all screwy
    # in the output from OIM. We stringify the data, replace all the text
    # newline characters with actual new lines and the strip off the
    # extra data.


def process_pkcs7(pkcs7, num_requests, **arguments):
    """Method to seperate the processing of pkcs7 string from the certificate retrieval logic"""
    cert_num = 0
    for certstring in pkcs7:
        extract_certs(certstring, **arguments)
        cert_num = cert_num + 1

    if cert_num != num_requests:
        raise CertificateMismatchException(num_requests, cert_num, 'Request and certificate received mismatch')
    return


def process_csr(bulk_csr, **arguments):
    """This function handles the entire processing of the request i.e.
    requesting. approving and then retrieving in sequence"""
    capi = ConnectAPI.ConnectAPI()

    try:
        reqid = capi.request_authenticated(bulk_csr, **arguments)
    except Exception, exc:
        if 'sslv3 alert bad certificate' in exc:
            raise BadCertificateException("Error connecting to server: %s.\n" + \
                                          "Your certificate is not trusted by the server" % exc)
        else:
            raise

    print 'Id is:', reqid
    arguments.update({'reqid':reqid})

    try:

        print 'Connecting to server to approve certificate...'
        capi.approve(**arguments)

        print 'Issuing certificate...'
        pkcs7raw = capi.retrieve_authenticated(**arguments)
        process_pkcs7(pkcs7raw, len(bulk_csr), **arguments)
    except httplib.HTTPException, exc:
        charlimit_textwrap('Connection to %s failed: %s'% (arguments['newrequrl'], exc))
        raise
    except SystemExit, exc:
        if 'sslv3 alert bad certificate' in exc:
            raise BadCertificateException("Error connecting to server: %s.\n" + \
                                          "Your certificate is not trusted by the server" % exc)
        else:
            raise

if __name__ == '__main__':
    try:
        os.umask(0177)
        arguments = parse_args()
        check_permissions(arguments['certdir'])
        ssl_context = get_ssl_context(**arguments)
        arguments.update({'ssl_context':ssl_context})

        OSGPKIUtils.start_timeout_clock(arguments['timeout'])

        if 'hostname' in arguments:
            hosts = [tuple(arguments['hostname'].strip() + arguments['alt_names'])]
        else:
            with open(arguments['hostfile'], 'rb') as hosts_file:
                host_lines = hosts_file.readlines()
            hosts = [tuple(line.split()) for line in host_lines if line.strip()]

        # Construct host list, skipping duplicates and empty lines
        # NOTE: the same host with different SANs are not considered duplicates
        requests = list()
        certs = list()
        charlimit_textwrap('Beginning request process...')
        for host in set(hosts):
            cn = host[0]
            sans = host[1:]
            # Remove / from service requests for proper FQDN formatting
            cert_obj = OSGPKIUtils.Cert(cn.replace('/', '-'),
                                        keypath=os.path.join(arguments['certdir'], cn + '-key.pem'),
                                        altnames=sans)
            certs.append(cert_obj)

        # We choose to write the keys before the request in case there are issues with the certs and only then perform
        # cleanup if there's a quota failure; it's better to have keys and no certs than it is to have certs and no keys
        if len(certs):
            charlimit_textwrap("Writing key(s) to %s" % arguments['certdir'])
            for cert in certs:
                # Handle already existing key file...
                if os.path.exists(cert.keypath):
                    old_keypath = re.sub(r'\.pem$', '-old.pem', cert.keypath)
                    print "Renaming existing key from %s to %s" % (cert.keypath, old_keypath)
                    os.rename(cert.keypath, old_keypath)
                cert.write_pkey()
            try:
                process_csr([cert.base64_csr() for cert in certs], **arguments)
            except SystemExit, exc:
                if 'certificate quota' in str(exc):
                    print "Cleaning up key(s) in %s" % arguments['certdir']
                    for key in [cert.keypath for cert in certs]:
                        os.remove(key)
                raise

    except SystemExit:
        # We need to specifically catch sys.exit() so that it doesn't hit the catchall Exception below and
        # print a confusing message for the user (SOFTWARE-1584)
        raise
    except SSLError, exc:
        print_exception_message(exc)
        sys.exit('Please check for valid certificate.\n')
    except KeyboardInterrupt, exc:
        print_exception_message(exc)
        sys.exit('''Interrupted by user\n''')
    except KeyError, exc:
        print_exception_message(exc)
        charlimit_textwrap('Key %s not found' % exc)
        sys.exit(1)
    except httplib.HTTPException, exc:
        print_exception_message(exc)
        charlimit_textwrap('Connection failed: %s' % (exc))
        sys.exit(1)
    except FileWriteException, exc:
        charlimit_textwrap(exc.message)
        charlimit_textwrap("The script will exit now\n")
        sys.exit(1)
    except FileNotFoundException, exc:
        charlimit_textwrap(exc.message + ':' + exc.filename)
        sys.exit(1)
    except (Exception_500response, NotOKException), exc:
        charlimit_textwrap('Request Failed. Status %s' % exc.status)
        charlimit_textwrap('Reason for failure %s' % exc.message)
        sys.exit(1)
    except CertificateMismatchException, exc:
        print 'The number of requests made was ', exc.request_num
        print 'The number of certificates received is ', exc.retrieve_num
        charlimit_textwrap(exc.message)
        sys.exit(1)
    except InsufficientArgumentException, exc:
        # I agree with mat on JIRA Software 1072 on that if a user enters
        # the script without options, there is no bug and shouldn't be
        # reported to goc. Hence bypassing call to print exception message
        charlimit_textwrap(exc.message)
        sys.stderr.write("Usage: osg-gridadmin-cert-request -h for help \n")
        sys.exit(2) # Fix for returning exit code of 2 as in all the other scripts.
    except (BadCertificateException, BadPassphraseException, HandshakeFailureException), exc:
        charlimit_textwrap(exc.message)
        sys.exit(1)
    except (AttributeError, OSError, ValueError, EOFError, SSL.SSLError, UnexpectedBehaviourException), exc:
        print_exception_message(exc)
        sys.exit(1)
    except Exception:
        print_uncaught_exception()
        charlimit_textwrap('Uncaught Exception : Please report the bug to goc@opensciencegrid.org.')
        sys.exit(1)
    sys.exit(0)
