#!/usr/bin/python
# -*- coding: utf-8 -*-

"""
This script is used to submit multiple certifcate requests and the intended user for the script is the GridAdmin.
This script requests certificates and then approves as well as issues them in bulk (limit of 50 at a time).
This script works in two modes:
1) Requesting single host certificate with -H option
2) Request multple host certificates with hostnames stored in a file
"""

import urllib
import httplib
import sys
import ConfigParser
try:
    import json
except ImportError:
    import simplejson as json
import time
import re
import os
import errno
import getpass
import StringIO
import base64
import M2Crypto
from optparse import OptionParser
from optparse import OptionGroup
import optparse
import OSGPKIUtils
import sys

# Set up Option Parser
#

def parse_args():
    usage = "usage: %prog [options] arg\nUsage:%prog -h/--help [for detailed explanations of options]"
    parser = OptionParser(usage)
    group = OptionGroup(parser, "Hostname Options",
                    "Use either of these options.\nSpecify hostname as a single hostname using -H/--hostname\nor specify from a file using -f/--hostfile."
                    )
    parser.add_option(
        '-k',
        '--pkey',
        action='store',
        dest='userprivkey',
        help="Specify Requestor's private key (PEM Format). If not specified will take the value of X509_USER_KEY or $HOME/.globus/userkey.pem"
            ,
        metavar='PKEY',
        default='',
        )
    parser.add_option(
        '-c',
        '--cert',
        action='store',
        dest='usercert',
        help="Specify Requestor's certificate (PEM Format). If not specified will take the value of X509_USER_CERT or $HOME/.globus/usercert.pem"
            ,
        default='',
        metavar='CERT',
        )
    group.add_option(
        '-H',
        '--hostname',
        action='store',
        dest='hostname',
        help='Specify the hostname or service/hostname for which you want to request the certificate for. If specified -f/--hostfile will be ignored',
        metavar='HOSTNAME',
        )
    group.add_option(
        '-f',
        '--hostfile',
        action='store',
        dest='hostfile',
        help='Filename with one hostname or service/hostname per line',
        metavar='HOSTFILE',
        default='hosts.txt',
        )
    parser.add_option(
        '-q',
        '--quiet',
        action='store_false',
        dest='verbose',
        default=True,
        help="don't print status messages to stdout",
        )
    parser.add_option_group(group)
    (args, values) = parser.parse_args()


    if not args.hostname:
        hostfile = args.hostfile
    else:
        hostname = args.hostname

    certdir = './'


    if args.userprivkey == '':
        try:
            userprivkey = os.environ["X509_USER_KEY"]
        except:
            userprivkey = str(os.environ["HOME"]) + '/.globus/userkey.pem'
    else:
        userprivkey = args.userprivkey
    
    if os.path.exists(userprivkey):
        pass
    else:
        sys.exit('Unable to locate the private key file:' + userprivkey)
    
    if args.usercert == '':
        try:
            usercert = os.environ["X509_USER_CERT"]
        except:
            usercert = str(os.environ["HOME"]) + '/.globus/usercert.pem'
    else:
        usercert = args.usercert
    
    if os.path.exists(usercert):
        pass
    else:
        sys.exit('Unable to locate the user certificate file:' + usercert)
    if not args.hostname:
        if os.path.exists(hostfile):
            pass
        else:
            sys.exit('Unable to locate the hostfile:' + hostfile)

    Config = ConfigParser.ConfigParser()
    if os.path.exists('OSGPKIClients.ini'):
        Config.read('OSGPKIClients.ini')
    elif os.path.exists('/etc/OSGPKIClients.ini'):
        Config.read('/etc/OSGPKIClients.ini')
    else:
        sys.exit("Missing config file: OSGPKIClients.ini\n")
    host = Config.get('OIMData', 'hostsec')
    requrl = Config.get('OIMData', 'requrl')
    appurl = Config.get('OIMData', 'appurl')
    issurl = Config.get('OIMData', 'issurl')
    returl = Config.get('OIMData', 'returl')
    content_type = Config.get('OIMData', 'content_type')

    arguments = dict()
    if vars().has_key('args'):
        arguments.update({'args' : args})
    if vars().has_key('values'):
        arguments.update({'values' : values})
    
    if vars().has_key('hostname'):
        arguments.update({'hostname' : hostname})
    if vars().has_key('domain'):
        arguments.update({'domain' : domain})
    if vars().has_key('outkeyfile'):
        arguments.update({'outkeyfile' : outkeyfile})
    if vars().has_key('num_requests'):
        arguments.update({'num_requests' : num_requests})
    arguments.update({'usercert' : usercert})
    arguments.update({'userprivkey' : userprivkey})
    arguments.update({'certdir' : certdir})
    if vars().has_key('hostfile'):
        arguments.update({'hostfile' : hostfile})
    if vars().has_key('host'):
        arguments.update({'host' : host})
    arguments.update({'requrl' : requrl})
    arguments.update({'appurl' : appurl})
    arguments.update({'issurl' : issurl})
    arguments.update({'returl' : returl})
    arguments.update({'content_type' : content_type})
    arguments.update({'Config' : Config})
    arguments.update({'issurl' : issurl})
    return arguments

#################################################


# We make the request here, causing the generation of the CSR and then
# pass the ID returned from the server along. The ID is the key that OIM
# uses for all certificate operations via the API
#

def connect_request(ssl_context, bulk_csr, arguments):
    print 'Connecting to server to request certificate...'
    params = urllib.urlencode({
        'csrs': bulk_csr,
        }, doseq=True)
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}

    conn = M2Crypto.httpslib.HTTPSConnection(arguments['host'],
            ssl_context=ssl_context)
    try:
        conn.request('POST', arguments['requrl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        print 'Connection to %s failed : %s' % (requrl, e)
        raise e
    data = response.read()
    if not 'OK' in response.reason:
        print "The request has failed for the following reason:\n%s" % json.loads(data)['detail'].split('--')[1].lstrip()
        print "Status : %s " % json.loads(data)['status']
        print 'Fatal error: Certificate request has failed.'
        print '''You can open a GOC ticket to track this issue by going to https://ticket.grid.iu.edu
'''
        sys.exit()
    conn.close()
    if 'FAILED' in data:
        print "The request has failed for the following reason:\n%s" % json.loads(data)['detail'].split('--')[1].lstrip()
        print "Status : %s " % json.loads(data)['status']
        print 'Fatal error: Certificate request has failed.'
        print '''You can open a GOC ticket to track this issue by going to https://ticket.grid.iu.edu
'''
        sys.exit(1)
    return_data = json.loads(data)
    for (key, value) in return_data.iteritems():
        if 'host_request_id' in key:
            reqid = value
            print 'Id is:', reqid
    arguments.update({'id' : reqid})
    return arguments


# ID from the request is passed in here via secure connection and the request
# gets approved automatically since it's a bulk request. We also issue the
# certificate (i.e. OIM contacts the CA on our behalf to get the cert) in this
# function
#

def connect_approve(ssl_context, arguments):
    print 'Connecting to server to approve certificate...'
    action = 'approve'
    params = urllib.urlencode({'host_request_id': arguments['id']})
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = M2Crypto.httpslib.HTTPSConnection(arguments['host'],
            ssl_context=ssl_context)
    try:
        conn.request('POST', arguments['appurl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        print 'Connection to %s failed: %s' % (arguments['appurl'], repr(e))
        raise e

    if not 'OK' in response.reason:
        print response.status, response.reason
        sys.exit(1)
    data = response.read()
    conn.close()
    issurl = arguments['issurl']
    if action == 'approve' and 'OK' in data:
        print 'Contacting Server to initiate certificate issuance.'
        newrequrl = arguments['Config'].get('OIMData', 'issurl')
        conn = M2Crypto.httpslib.HTTPSConnection(arguments['host'],
                ssl_context=ssl_context)
        try:
            conn.request('POST', newrequrl, params, headers)
            response = conn.getresponse()
        except httplib.HTTPException, e:
            print 'Connection to %s failed: %s' % (newrequrl, e)
            raise e
        data = response.read()
        conn.close()
        if 'FAILED' in data:
            print "The request has failed for the following reason:\n%s" % json.loads(data)['detail'].split('--')[1].lstrip()
            print "Status : %s " % json.loads(data)['status']
            print 'Fatal error: Certificate request has failed.'
            print '''You can open a GOC ticket to track this issue by going to https://ticket.grid.iu.edu
'''
            sys.exit(1)
    elif not 'OK' in data:
        print "The request has failed for the reason: %s" % json.loads(data)['detail']
        sys.exit(1)
    elif action != 'approve':
        print "Request not approved by the Grid Admin. Exiting now.\n"
        sys.exit(0)


# Here's where things have gotten dicey during the testing phase -
# We retrieve the certificate from OIM after it has retrieved it from the CA
# This is where things tend to fall apart - if the delay is to long and the
# request to the CA times out, the whole script operation fails. I'm not
# terribly pleased with that at the moment, but it is out of my hands since
# a GOC staffer has to reset the request to be able to retrieve the
# certificate
#

def write_certs(host, pkcs7raw, i, arguments):
    pkcs7raw = str(pkcs7raw)
    filetype = 'pkcs7-cert'
    fileext = 'pem'
    filename = '%s.%s.%s' % (filetype, arguments['id'], fileext)
    pem_filename = '%s-%s.%s' % (host, i, 'pem')
    cwd = os.getcwd()
    try:
        os.chdir(arguments['certdir'])
    except OSError, e:
        sys.exit('''The directory %s does not exist or you cannot access the directory
.Please report the bug to goc@opensciencegrid.org.a
 %s''',
                 arguments['certdir'], e)
    try:
        certfile = open(filename, 'w+')
        certfile.write(pkcs7raw)
        certfile.close()
        os.system('openssl pkcs7 -print_certs -in ' + filename
                  + ' -out ' + pem_filename)
        os.remove(filename)
    except OSError, e:
        sys.exit('''You may not have write permission to the directory %s
.Please report the bug to goc@opensciencegrid.org.
 %s''',
                 arguments['certdir'], e)
    os.chdir(cwd)
    print '\nCertificate written to %s%s \n' % (arguments['certdir'], pem_filename)
    return


def connect_retrieve(arguments):
    iterations = 1
    print 'Issuing certificate...'
    params = urllib.urlencode({'host_request_id': arguments['id']})
    headers = {'Content-type': arguments['content_type'],
               'User-Agent': 'OIMGridAPIClient/0.1 (OIM Grid API)'}
    conn = httplib.HTTPSConnection(arguments['host'])
    try:
        conn.request('POST', arguments['returl'], params, headers)
        response = conn.getresponse()
    except httplib.HTTPException, e:
        print 'Connection to %s failed: %s' % (newurl, e)
        raise httplib.HTTPException
    data = response.read()
    if not 'PENDING' in response.reason:
        if not 'OK' in response.reason:
            print "The request has failed for the following reason:\n%s" % json.loads(data)['detail'].lstrip()
            print "Status : %s " % json.loads(data)['status']
            print 'Fatal error: Certificate request has failed.'
            print '''You can open a GOC ticket to track this issue by going to
 https://ticket.grid.iu.edu
'''
            sys.exit(1)
    conn.close()
    print 'Waiting for response from Certificate Authority. Please wait.'
    while 'PENDING' in data:
        conn.request('POST', arguments['returl'], params, headers)
        try:
            response = conn.getresponse()
        except httplib.HTTPException, e:
            print 'Connection to %s failed: %s' % (newurl, e)
            raise httplib.HTTPException
        data = response.read()
        conn.close()
        if 'PENDING' in data:
            time.sleep(5)
            iterations = iterations + 1
            if iterations % 6 == 0:
                print '.',
                sys.stdout.flush()
            if iterations > 60:
                print "Maximum number of attempts reached. This script will now exit."
                print  " You can open goc ticket to track this issue by going to https://ticket.grid.iu.edu\n"
                sys.exit(1)
        else:
            pass
    pkcs7raw = json.dumps(json.loads(data), sort_keys=True, indent=2)
    if 'FAILED' in data:
        print "The request has failed for the following reason:\n%s" % json.loads(data)['detail'].split('--')[1].lstrip()
        print "Status : %s " % json.loads(data)['status']
        print 'Fatal error: Certificate request has failed.'
        print '''You can open a GOC ticket to track this issue by going to
 https://ticket.grid.iu.edu
'''
        sys.exit(1)

    # The slice and dice on the JSON output to get the certificate out
    # happens here - the problem is that the new lines are getting all screwy
    # in the output from OIM. We stringify the data, replace all the text
    # newline characters with actual new lines and the strip off the
    # extra data. There's probably a more efficient way to do this, but this
    # was the quick and dirty solution.
    #
    pkcs7raw = str(pkcs7raw)
    pkcs7raw = re.sub('\\\\n', '\n', pkcs7raw)
    pkcs7raw = pkcs7raw.split('[')[1]
    pkcs7raw = pkcs7raw.split(']')[0].split(',')
    i = 0
    cert_num = 0
    if arguments.has_key('hostfile'):
        hostfile = open(arguments['hostfile'])
    while cert_num < num_requests and i < len(pkcs7raw):
        certstring = str(pkcs7raw[i]).split('"')[1]
        if 'PKCS7' in certstring:
            if arguments.has_key('hostfile'):
                host = hostfile.readline().rstrip('\n')
            else:
                host = arguments['hostname']
            write_certs(host, certstring, cert_num, arguments)
            cert_num = cert_num + 1
        i = i + 1
    if cert_num != num_requests:
        print 'The number of requests made was ', num_requests
        print 'The number of certificates received is ', cert_num
        sys.exit('Request and certificate received mismatch')
    return


def create_certificate(line, count, config_items):
    print 'Generating certificate...'
    keyname = line + '-' + str(count) + '-key.pem'
    cert_obj = OSGPKIUtils.Cert()
    cert_obj.CreatePKey(keyname)
    new_csr = cert_obj.CreateX509Request( **config_items)
    csr = new_csr.as_pem().replace('-----BEGIN CERTIFICATE REQUEST-----\n',
                              ''
                              ).replace('-----END CERTIFICATE REQUEST-----\n'
                    , '')
    
    return csr

if __name__ == '__main__':
    try:
        arguments = parse_args()
        def prompt_for_password(verify):

        # If verify == True, we are supposed to verify password.

            return getpass.getpass("Please enter the pass phrase for '%s':"
                                    % arguments['userprivkey'])


        ssl_context = M2Crypto.SSL.Context('sslv3')
        ssl_context.load_cert_chain(arguments['usercert'], arguments['userprivkey'],
                                    callback=prompt_for_password)

        config_items = {}
    # ############################# Pipelining the bulk Certificate request process to send them at once##################################

        bulk_csr = list()
        count = 0
        num_requests = 0
        if not arguments.has_key('hostname'):
            hosts = open(arguments['hostfile'], 'rb')
            for line in hosts:
                count += 1
                line = line.rstrip('\n')
                config_items.update({'CN': line})  # ### New Config item list for every host#######
                print 'Beginning request process for', line
                csr = create_certificate(line, count, config_items)
                bulk_csr.append(csr)
                num_requests = num_requests + 1
                if count == 50:
                    connect_request(ssl_context, bulk_csr, arguments)
                    connect_approve(ssl_context, arguments)
                    connect_retrieve(arguments)
                    bulk_csr = ''
                    count = 0

    # ####################################################################################################################################

            if count != 0 and count != 50:
                connect_request(ssl_context, bulk_csr, arguments)
                connect_approve(ssl_context, arguments)
                connect_retrieve(arguments)
            hosts.close()
        else:
            hostname = arguments['hostname'].rstrip('\n')
            config_items.update({'CN': hostname})  # ### New Config item list for every host#######
            num_requests = 1
            print 'Beginning request process for', hostname        
            csr = create_certificate(hostname, count, config_items)
            connect_request(ssl_context, csr, arguments)
            connect_approve(ssl_context, arguments)
            connect_retrieve(arguments)
    except EOFError, e:
        sys.exit("End of File Error: Check if the standard input is enabled\nError %s" % e)
    except KeyboardInterrupt, k:
        print k
        sys.exit('''Interrupted by user\n''')
    except Exception, e:
        if str(e) != '0':
            sys.exit('''Uncaught Exception : %s\n
Please report the bug to goc@opensciencegrid.org.
''' % e
                 )
    sys.exit(0)